#!/bin/bash
# Script Name: pocket-dns.sh
# v1.1.0
# Tested on: 
# CentOS 7, CentOS 8 (need selinux confiure), CentOS 9
# Alma Linux 8, Alma 9
# Rocky Linux 8, Rocky 9
# RedOS 7.3.x, RedOS 7.3c, RedOS 8.x
# Oracle Linux 7 (need manual install bind), Oracle 8, Oracle 9
# Fedora 37, Fedora 39
# 
# Requirements: 
# 1. ping to server by ip SUCCESS
# 2. firewall allow 53 port
# 3. ssh to server SUCCESS (for add_resolv command)
# 
# Install, configure DNS. Can replace resolv.conf on remote servers.
# You can also restore the old resolv.conf.
# There is an option to delete the Pocket DNS by cleaning up after yourself.


# === SETTINGS
DOMAIN=example.com
DNS_IP=auto # auto (try get ip from system) or <dns_ip_adress> (192.168...)

# Server Name without domain:
declare -A servers=(
["vm-server01"]="192.168.130.141"
["vm-server02"]="192.168.130.142"
["vm-server03"]="192.168.130.143"
)

SERIAL_NUMBER=20240404

#NAMED_CONF=/etc/named.conf
#MATER_ZONE=/var/named/master/$DOMAIN

NAMED_CHECKCONF=/usr/sbin/named-checkconf # /usr/sbin/ centos, alt
NAMED_CHECKZONE=/usr/sbin/named-checkzone



# ==== COLOR VARS
CLEAR_COLOR="\033[0m"
RED_COLOR="\033[31m"
GREEN_COLOR="\033[32m"
PURPLE_COLOR='\033[0;35m'
BLUE_COLOR='\033[0;34m'

# === SCRIPT
# Set vars
if [ $DNS_IP == "auto" ]; then
	DNS_IP=`hostname -I | awk '{print $1}'`
	echo "DNS_IP is set to $DNS_IP (auto mode is on)"
	echo "Domain: $DOMAIN"
	echo ""
fi


# Functions
function fail_ok()
{
    if [ $? -eq 0 ];then
        echo -ne "[${GREEN_COLOR}OK${CLEAR_COLOR}] $1"
        echo
    else
        echo -ne "[${RED_COLOR}fail${CLEAR_COLOR}] $1"
        echo
    fi
}

function reverse_ip()
{
    IFS='.'
    read -a strarr <<< "$1"
    echo "${strarr[3]}.${strarr[2]}.${strarr[1]}.${strarr[0]}"
    IFS=''
}

function cut_ip()
{
    IFS='.'
    read -a strarr <<< "$1"
    case "$2" in


        "1")
         echo "${strarr[0]}"
         ;;

        "2")
         echo "${strarr[0]}.${strarr[1]}"
         ;;

        "3")
         echo "${strarr[0]}.${strarr[1]}.${strarr[2]}"
         ;;

    esac
    IFS=''
}

function get_os_value() {
    # Check quotes
    cat /etc/os-release | grep ^$1 | grep \" > /dev/null 2>&1

    # Value with quotes
    if [[ $? == 0 ]]; then
        cat /etc/os-release | grep ^$1 | grep -o '"[^"]*"' | cut -c2- | rev | cut -c2- | rev
    # Value without quotes
    else
        cat /etc/os-release | grep ^$1 | grep -o '[^=]*$'
    fi
	# NAME: CentOS Linux, Oracle Linux Server, RED OS, CentOS Stream, 
	# AlmaLinux, Rocky Linux, ALT Server, openSUSE Leap, Fedora Linux, 
	# Debian GNU/Linux, Ubuntu, Astra Linux (Orel)
	#
	# ID: centos, ol, redos, almalinux, rocky, altlinux, opensuse-leap, fedora, debian, ubuntu, astra
}
OS=`get_os_value "NAME"`

function init_configs()
{
	if [[ $OS == "CentOS Linux" ]] || [[ $OS == "RED OS" ]]; then
		NAMED_CONF=/etc/named.conf
		MASTER_ZONE=/var/named/master/$DOMAIN
		MASTER_ZONE_DIR=`dirname $MASTER_ZONE`
		fail_ok "OS: CentOS/RedOS"
		return 1
	fi
	
	if [[ $OS == "CentOS Stream" ]] || [[ $OS == "AlmaLinux" ]] || [[ $OS == "Rocky Linux" ]] || [[ $OS == "Oracle Linux Server" ]] || [[ $OS == "Fedora Linux" ]]; then
		NAMED_CONF=/etc/named.conf
		MASTER_ZONE=/var/named/master/$DOMAIN
		MASTER_ZONE_DIR=`dirname $MASTER_ZONE`
		fail_ok "OS: CentOS Stream 8/9 or Alma Linux 8/9 or Rocky Linux 8/9 or Oracle 8/9 or Fedora"
		return 1
	fi
	
	if [[ $OS == "ALT Server" ]]; then
		NAMED_CONF=/var/lib/bind/etc/named.conf
		MASTER_ZONE=/var/lib/bind/zone/master/$DOMAIN
		MASTER_ZONE_DIR=`dirname $MASTER_ZONE`
		fail_ok "OS: Alt Linux"
		return 1
	fi
	
	echo "Unknown OS. Aborting script..."
	exit 2
}




# 1. Install
function install_dns
{
	if [[ $OS == "CentOS Linux" ]] || [[ $OS == "RED OS" ]]; then
		fail_ok "OS: CentOS/RedOS"
		yum install bind -y # dnf not supported on vanila CentOS 7
		systemctl enable named
	fi
	
	if [[ $OS == "CentOS Stream" ]] || [[ $OS == "AlmaLinux" ]] || [[ $OS == "Rocky Linux" ]] || [[ $OS == "Oracle Linux Server" ]] || [[ $OS == "Fedora Linux" ]]; then
		fail_ok "OS: CentOS Stream 8/9 or Alma Linux 8/9 or Rocky Linux 8/9 or Oracle 8/9 or Fedora"
		dnf install bind -y
		systemctl enable named
	fi
	
	if [[ $OS == "ALT Server" ]]; then
		fail_ok "Alt Linux"
		apt-get install bind -y
	fi
}

function configure_dns
{
	# 2. modify named.conf
	REVERSE_IP_ZONE=`cut_ip $DNS_IP 3`
	REVERSE_IP_ZONE=`reverse_ip $REVERSE_IP_ZONE`
	REVERSE_IP_ZONE=`echo $REVERSE_IP_ZONE | cut -c2-`
	REVERSE_ZONE=$MASTER_ZONE_DIR/$REVERSE_IP_ZONE.db


cat << EOF > $NAMED_CONF
//
// Managed by pocket-dns.sh
// Do not edit this file.
//

options {
        listen-on port 53 { 127.0.0.1; localhost; $DNS_IP; };
        listen-on-v6 port 53 { ::1; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        recursing-file  "/var/named/data/named.recursing";
        secroots-file   "/var/named/data/named.secroots";
        allow-query     { any; };

        /*
         - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
         - If you are building a RECURSIVE (caching) DNS server, you need to enable
           recursion.
         - If your recursive DNS server has a public IP address, you MUST enable access
           control to limit queries to your legitimate users. Failing to do so will
           cause your server to become part of large scale DNS amplification
           attacks. Implementing BCP38 within your network would greatly
           reduce such attack surface
        */
        recursion yes;

        dnssec-validation yes;

        /* Path to ISC DLV key */
        bindkeys-file "/etc/named.root.key";

        managed-keys-directory "/var/named/dynamic";

        pid-file "/run/named/named.pid";
        session-keyfile "/run/named/session.key";
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
        type hint;
        file "named.ca";
};

zone "$DOMAIN" IN {
        type master;
        file "master/$DOMAIN";
        allow-transfer { $DNS_IP; };
        allow-update { none; };
};

zone "$REVERSE_IP_ZONE.in-addr.arpa" IN {
        type master;
        file "master/$REVERSE_IP_ZONE.db";
        allow-update { none; };
};

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";

EOF


# 3. Add Zones
mkdir -p $MASTER_ZONE_DIR
fail_ok "Create Master Zone Dir"

cat << EOF > $MASTER_ZONE
\$TTL 14400

$DOMAIN.     IN      SOA     ns1.$DOMAIN. admin.$DOMAIN. (
        $SERIAL_NUMBER        ; Serial
        10800           ; Refresh
        3600            ; Retry
        604800          ; Expire
        604800          ; Negative Cache TTL
)

                IN      NS      ns1.$DOMAIN.
                IN      NS      ns2.$DOMAIN.

                IN      MX 10   mx.$DOMAIN.
                IN      MX 20   mx2.$DOMAIN.

@               IN      A       $DNS_IP
localhost       IN      A       127.0.0.1
ns1             IN      A       $DNS_IP
ns2             IN      A       192.168.1.3

www             IN      CNAME   $DOMAIN.


EOF

cat << EOF > $REVERSE_ZONE
\$TTL 14400

$REVERSE_IP_ZONE.in-addr.arpa. IN SOA ns1.$DOMAIN. admin.$DOMAIN. (
        $SERIAL_NUMBER        ; Serial
        10800           ; Refresh
        3600            ; Retry
        604800          ; Expire
        604800          ; Negative Cache TTL
)

							IN      NS      ns1.$DOMAIN.

EOF

# ======================================= A Records
for item in "${!servers[@]}"
	do
		server=$item
		ip=${servers[$item]}
		echo "$server	IN	A	$ip" >> $MASTER_ZONE
    done

# ======================================= PTR Records
for item in "${!servers[@]}"
    do
		server=$item
		ip=${servers[$item]}
		rev_ip=`reverse_ip "${ip}"`
		echo "$rev_ip.in-addr.arpa.        IN      PTR     ${server}.$DOMAIN". >> $REVERSE_ZONE
	done

systemctl restart named
}

function check_dns()
{
	echo "check DNS conf"
	$NAMED_CHECKCONF -z $NAMED_CONF
	echo ""
	
	nslookup ? &> /dev/null
	if [ $? -ne 1 ]; then
		echo "nslookup not installed. Abort script..."
		return 3
	fi
	
	
	echo "Check via nslookup"
	for item in "${!servers[@]}"
    do
		server=$item
		ip=${servers[$item]}
		nslookup $server &> /dev/null
		fail_ok "Check host by name ($server)"
		nslookup $ip &> /dev/null
		fail_ok "Check host by ip ($ip)"
		echo ""
	done
}


function add_resolv_conf
{
	COMMAND1="search $DOMAIN"
	COMMAND2="nameserver $DNS_IP"
	
    for item in "${!servers[@]}"
        do
			server=$item
			ip=${servers[$item]}
			if [ ! -f resolv_conf.saved ]; then
				scp ${ip}:/etc/resolv.conf resolv_conf.saved
			fi
            ssh -o BatchMode=yes -o "StrictHostKeyChecking no" ${ip} -C 'echo "# Generated by pocket-dns.sh script" > /etc/resolv.conf'
            ssh -o BatchMode=yes -o "StrictHostKeyChecking no" ${ip} -C "echo $COMMAND1 >> /etc/resolv.conf"
            ssh -o BatchMode=yes -o "StrictHostKeyChecking no" ${ip} -C "echo $COMMAND2 >> /etc/resolv.conf"
            fail_ok "Add string to $item"
        done
}

function restore_resolv_conf
{
    for item in "${!servers[@]}"
        do
			server=$item
			ip=${servers[$item]}
			if [ -f resolv_conf.saved ]; then
				scp resolv_conf.saved ${ip}:/etc/resolv.conf
			fi
            fail_ok "Add string to $item"
        done
}

function uninstall_dns
{
	systemctl stop named
	systemctl disable named
	yum remove bind -y
	rm -rf /var/named
	rm -f /etc/named.conf.rpmnew
	rm -f /etc/named.conf.rpmsave
	rm -f resolv_conf.saved
}

command() {
case "$1" in
		install)
		install_dns
		init_configs
		configure_dns
		;;

	configure | reconfigure)
		init_configs
		configure_dns
		;;

	check)
		init_configs
		check_dns
		;;

	add-resolv)
		add_resolv_conf
		;;

	restore-resolv)
		restore_resolv_conf
		;;

	uninstall)
		restore_resolv_conf
		uninstall_dns
		;;

	*)
		echo "Usage: $0 { install | check | configure | add-resolv | restore-resolv | uninstall }"
		echo ""
		echo "    install - Install Pocket DNS"
		echo "    check - Check bind (DNS) main config"
		echo "    configure - Reconfigure DNS"
		echo "    add_resolv - Save original files (resolv.conf.saved) from remote servers & change resolv.conf on remote servers"
		echo "    restore_resolv - Restore original resolv.conf (from resolv.conf.saved)"
		echo "    uninstall - Uninstall DNS & restore resolv.conf on remote servers, lists on SERVER_IP array in this script"
		echo ""
		exit 1
  esac
}

command "$1"


exit 0
# For test only!
# echo "search example.com" > /etc/resolv.conf
# echo "nameserver $(hostname -I | awk '{print $1}')" >> /etc/resolv.conf
# echo "nameserver 8.8.8.8" >> /etc/resolv.conf



# On Clients:
# cat /etc/resolv.conf
# search $DOMAIN
# namedserver <ip>